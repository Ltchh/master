#define _CRT_SECURE_NO_WARNINGS 1

#include<stdio.h>


//数据类型详解:

// 整形家族{
	// char:	%c	unsigned char(无符号)/signed char(有符号)	
	// 
	// short:		unsigend short(无符号)/sigend short (有符号)
	// 
	// int:		%d	unsigend int(无符号)/sigend int(有符号)
	//	
	// long:	%ld	unsigend long(无符号)/sigend long(有符号)
	// 
	// long long:%lld	unsigend long long(无符号)/sigend long long(有符号)
//}

//浮点型家族{
	//float:	%lf	unsigend float(无符号)/sigend float(有符号)
	//
	//double:	%f	unsigend double(无符号)/sigend double(有符号)
//}

//构造类型-自定义类型{
	// 数组类型:	
	// 
	// 结构体类型: struct
	// 
	// 枚举类型:	enum
	//
	// 联合类型:	union
	//
//}

//指针类型{
	// int*	pi;
	// 
	//	char* arr
	// 
	//	float* arr
	// 
	//	vood* pc
	//
//}

//空类型
//通常用于函数返回类型,函数参数,指针类型:

int main() {

	int a = -10;

	//整数在内存中以2进制的形式存储
	//对整数而言:
	//整数二进制有3中表现形式:原码-反码-补码
		//正整数: 原码,反码,补码 都相同
		// 
		//负整数: 原码,反码,补码需要进行计算
		// 例:
			//1000  0000 0000 0000 0000 0000 0000 1010	原码
			//1111  1111 1111 1111 1111 1111 1111 0101	反码
			//1111  1111 1111 1111 1111 1111 1111 0110	补码
			//原码的符号位不变,其他位取反,得到反码
			//反码+1,得到补码

	//整数在内存中是以补码的形式存储的!

	// 1-1(cpu只有加法器)
		// 0000 0000 0000 0000 0000 0000 0000 0001	(1)正数原反补相同
		// 1000 0000 0000 0000 0000 0000 0000 0001  (-1)负数原反补需要计数
	//运算:1111	1111 1111 1111 1111 1111 1111 1110	(-1反码)
	//运算:1111	1111 1111 1111 1111 1111 1111 1111	(-1,加1补码)
	//两个数相加:// 0000 0000 0000 0000 0000 0000 0000 0001
	//				1111 1111 1111 1111 1111 1111 1111 1111
	//			   10000 0000 0000 0000 0000 0000 0000 0000(结果为0 符号位被挤出)


	return 0;
}

//大端字节序:
	//把数据的低位字节序放在高位地址处,高位字节序放在低位地址处;
	// 
//小端字节序:
	//把数据地位字节序放在低位地址处,高位字节序放在高位地址处;